<!DOCTYPE html>
<html class="staticrypt-html">

<head>
    <meta charset="utf-8" />
    <title>Marine Studies Presentation</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
    <meta http-equiv="pragma" content="no-cache" />

    <style>
        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }
        
        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }
        
        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #ffffff;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }
        
        .staticrypt-form input[type="password"],
        input[type="text"] {
            background: inherit;
            border: 0;
            box-sizing: border-box;
            /* This ensures padding is included in the total width */
            font-size: 14px;
            outline: 0;
            padding: 15px 30px 15px 15px;
            /* Adjust the padding to ensure there is space for the icon */
            width: 100%;
        }
        
        .staticrypt-password-container {
            position: relative;
            outline: 0;
            background: #f2f2f2;
            width: 100%;
            border: 0;
            margin: 0 0 15px;
            box-sizing: border-box;
        }
        
        .staticrypt-toggle-password-visibility {
            cursor: pointer;
            height: 20px;
            opacity: 60%;
            padding: 13px;
            position: absolute;
            right: 0;
            top: 50%;
            transform: translateY(-50%);
            width: 20px;
        }
        
        .staticrypt-form .staticrypt-decrypt-button {
            text-transform: uppercase;
            outline: 0;
            background: #F7987F;
            width: 100%;
            border: 0;
            padding: 15px;
            color: #ffffff;
            font-size: 14px;
            cursor: pointer;
        }
        
        .staticrypt-form .staticrypt-decrypt-button:hover,
        .staticrypt-form .staticrypt-decrypt-button:active,
        .staticrypt-form .staticrypt-decrypt-button:focus {
            background: #F7987F;
            filter: brightness(92%);
        }
        
        .staticrypt-html {
            height: 100%;
        }
        
        .staticrypt-body {
            height: 100%;
            margin: 0;
        }
        
        .staticrypt-content {
            height: 100%;
            margin-bottom: 1em;
            background: #FFD5C2;
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
        
        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }
        
        .staticrypt-title {
            font-size: 1.5em;
        }
        
        label.staticrypt-remember {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
        }
        
        .staticrypt-remember input[type="checkbox"] {
            transform: scale(1.5);
            margin-right: 1em;
        }
        
        .hidden {
            display: none !important;
        }
        
        .staticrypt-spinner-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .staticrypt-spinner {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid gray;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border 0.75s linear infinite;
            animation: spinner-border 0.75s linear infinite;
            animation-duration: 0.75s;
            animation-timing-function: linear;
            animation-delay: 0s;
            animation-iteration-count: infinite;
            animation-direction: normal;
            animation-fill-mode: none;
            animation-play-state: running;
            animation-name: spinner-border;
        }
        
        @keyframes spinner-border {
            100% {
                transform: rotate(360deg);
            }
        }
    </style>
</head>

<body class="staticrypt-body">
    <div id="staticrypt_loading" class="staticrypt-spinner-container">
        <div class="staticrypt-spinner"></div>
    </div>

    <div id="staticrypt_content" class="staticrypt-content hidden">
        <div class="staticrypt-page">
            <div class="staticrypt-form">
                <div class="staticrypt-instructions">
                    <p class="staticrypt-title">Marine Studies Presentation</p>
                    <p>
                        <p>Login</p>
                    </p>
                </div>

                <hr class="staticrypt-hr" />

                <form id="staticrypt-form" action="#" method="post">
                    <div class="staticrypt-password-container">
                        <input id="staticrypt-password" type="password" name="password" placeholder="Password" autofocus />

                        <img class="staticrypt-toggle-password-visibility" alt="template_toggle_show" title="template_toggle_show" src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                        />
                    </div>

                    <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember Me
                        </label>

                    <input type="submit" class="staticrypt-decrypt-button" value="Unlock" />
                </form>
            </div>
        </div>
    </div>

    <script>
        // these variables will be filled when generating the file - the template format is 'variable_name'
        const staticryptInitiator =
            ((function() {
                const exports = {};
                const cryptoEngine = ((function() {
                    const exports = {};
                    const {
                        subtle
                    } = crypto;

                    const IV_BITS = 16 * 8;
                    const HEX_BITS = 4;
                    const ENCRYPTION_ALGO = "AES-CBC";

                    /**
                     * Translates between utf8 encoded hexadecimal strings
                     * and Uint8Array bytes.
                     */
                    const HexEncoder = {
                        /**
                         * hex string -> bytes
                         * @param {string} hexString
                         * @returns {Uint8Array}
                         */
                        parse: function(hexString) {
                            if (hexString.length % 2 !== 0) throw "Invalid hexString";
                            const arrayBuffer = new Uint8Array(hexString.length / 2);

                            for (let i = 0; i < hexString.length; i += 2) {
                                const byteValue = parseInt(hexString.substring(i, i + 2), 16);
                                if (isNaN(byteValue)) {
                                    throw "Invalid hexString";
                                }
                                arrayBuffer[i / 2] = byteValue;
                            }
                            return arrayBuffer;
                        },

                        /**
                         * bytes -> hex string
                         * @param {Uint8Array} bytes
                         * @returns {string}
                         */
                        stringify: function(bytes) {
                            const hexBytes = [];

                            for (let i = 0; i < bytes.length; ++i) {
                                let byteString = bytes[i].toString(16);
                                if (byteString.length < 2) {
                                    byteString = "0" + byteString;
                                }
                                hexBytes.push(byteString);
                            }
                            return hexBytes.join("");
                        },
                    };

                    /**
                     * Translates between utf8 strings and Uint8Array bytes.
                     */
                    const UTF8Encoder = {
                        parse: function(str) {
                            return new TextEncoder().encode(str);
                        },

                        stringify: function(bytes) {
                            return new TextDecoder().decode(bytes);
                        },
                    };

                    /**
                     * Salt and encrypt a msg with a password.
                     */
                    async function encrypt(msg, hashedPassword) {
                        // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
                        // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
                        const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

                        const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

                        const encrypted = await subtle.encrypt({
                                name: ENCRYPTION_ALGO,
                                iv: iv,
                            },
                            key,
                            UTF8Encoder.parse(msg)
                        );

                        // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
                        return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
                    }
                    exports.encrypt = encrypt;

                    /**
                     * Decrypt a salted msg using a password.
                     *
                     * @param {string} encryptedMsg
                     * @param {string} hashedPassword
                     * @returns {Promise<string>}
                     */
                    async function decrypt(encryptedMsg, hashedPassword) {
                        const ivLength = IV_BITS / HEX_BITS;
                        const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
                        const encrypted = encryptedMsg.substring(ivLength);

                        const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

                        const outBuffer = await subtle.decrypt({
                                name: ENCRYPTION_ALGO,
                                iv: iv,
                            },
                            key,
                            HexEncoder.parse(encrypted)
                        );

                        return UTF8Encoder.stringify(new Uint8Array(outBuffer));
                    }
                    exports.decrypt = decrypt;

                    /**
                     * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
                     *
                     * @param {string} password
                     * @param {string} salt
                     * @returns {Promise<string>}
                     */
                    async function hashPassword(password, salt) {
                        // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
                        // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
                        let hashedPassword = await hashLegacyRound(password, salt);

                        hashedPassword = await hashSecondRound(hashedPassword, salt);

                        return hashThirdRound(hashedPassword, salt);
                    }
                    exports.hashPassword = hashPassword;

                    /**
                     * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
                     * compatibility.
                     *
                     * @param {string} password
                     * @param {string} salt
                     * @returns {Promise<string>}
                     */
                    function hashLegacyRound(password, salt) {
                        return pbkdf2(password, salt, 1000, "SHA-1");
                    }
                    exports.hashLegacyRound = hashLegacyRound;

                    /**
                     * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
                     * remember-me/autodecrypt links, we need to support going from that to more iterations.
                     *
                     * @param hashedPassword
                     * @param salt
                     * @returns {Promise<string>}
                     */
                    function hashSecondRound(hashedPassword, salt) {
                        return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
                    }
                    exports.hashSecondRound = hashSecondRound;

                    /**
                     * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
                     * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
                     *
                     * @param hashedPassword
                     * @param salt
                     * @returns {Promise<string>}
                     */
                    function hashThirdRound(hashedPassword, salt) {
                        return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
                    }
                    exports.hashThirdRound = hashThirdRound;

                    /**
                     * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
                     *
                     * @param {string} password
                     * @param {string} salt
                     * @param {int} iterations
                     * @param {string} hashAlgorithm
                     * @returns {Promise<string>}
                     */
                    async function pbkdf2(password, salt, iterations, hashAlgorithm) {
                        const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

                        const keyBytes = await subtle.deriveBits({
                                name: "PBKDF2",
                                hash: hashAlgorithm,
                                iterations,
                                salt: UTF8Encoder.parse(salt),
                            },
                            key,
                            256
                        );

                        return HexEncoder.stringify(new Uint8Array(keyBytes));
                    }

                    function generateRandomSalt() {
                        const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

                        return HexEncoder.stringify(new Uint8Array(bytes));
                    }
                    exports.generateRandomSalt = generateRandomSalt;

                    async function signMessage(hashedPassword, message) {
                        const key = await subtle.importKey(
                            "raw",
                            HexEncoder.parse(hashedPassword), {
                                name: "HMAC",
                                hash: "SHA-256",
                            },
                            false, ["sign"]
                        );
                        const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

                        return HexEncoder.stringify(new Uint8Array(signature));
                    }
                    exports.signMessage = signMessage;

                    function getRandomAlphanum() {
                        const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

                        let byteArray;
                        let parsedInt;

                        // Keep generating new random bytes until we get a value that falls
                        // within a range that can be evenly divided by possibleCharacters.length
                        do {
                            byteArray = crypto.getRandomValues(new Uint8Array(1));
                            // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
                            parsedInt = byteArray[0] & 0xff;
                        } while (parsedInt >= 256 - (256 % possibleCharacters.length));

                        // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
                        const randomIndex = parsedInt % possibleCharacters.length;

                        return possibleCharacters[randomIndex];
                    }

                    /**
                     * Generate a random string of a given length.
                     *
                     * @param {int} length
                     * @returns {string}
                     */
                    function generateRandomString(length) {
                        let randomString = "";

                        for (let i = 0; i < length; i++) {
                            randomString += getRandomAlphanum();
                        }

                        return randomString;
                    }
                    exports.generateRandomString = generateRandomString;

                    return exports;
                })());
                const codec = ((function() {
                    const exports = {};
                    /**
                     * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
                     *
                     * @param cryptoEngine - the engine to use for encryption / decryption
                     */
                    function init(cryptoEngine) {
                        const exports = {};

                        /**
                         * Top-level function for encoding a message.
                         * Includes password hashing, encryption, and signing.
                         *
                         * @param {string} msg
                         * @param {string} password
                         * @param {string} salt
                         *
                         * @returns {string} The encoded text
                         */
                        async function encode(msg, password, salt) {
                            const hashedPassword = await cryptoEngine.hashPassword(password, salt);

                            const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

                            // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
                            // it in localStorage safely, we don't use the clear text password)
                            const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

                            return hmac + encrypted;
                        }
                        exports.encode = encode;

                        /**
                         * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
                         * we don't need to hash the password multiple times.
                         *
                         * @param {string} msg
                         * @param {string} hashedPassword
                         *
                         * @returns {string} The encoded text
                         */
                        async function encodeWithHashedPassword(msg, hashedPassword) {
                            const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

                            // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
                            // it in localStorage safely, we don't use the clear text password)
                            const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

                            return hmac + encrypted;
                        }
                        exports.encodeWithHashedPassword = encodeWithHashedPassword;

                        /**
                         * Top-level function for decoding a message.
                         * Includes signature check and decryption.
                         *
                         * @param {string} signedMsg
                         * @param {string} hashedPassword
                         * @param {string} salt
                         * @param {int} backwardCompatibleAttempt
                         * @param {string} originalPassword
                         *
                         * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
                         */
                        async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
                            const encryptedHMAC = signedMsg.substring(0, 64);
                            const encryptedMsg = signedMsg.substring(64);
                            const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

                            if (decryptedHMAC !== encryptedHMAC) {
                                // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
                                // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
                                originalPassword = originalPassword || hashedPassword;
                                if (backwardCompatibleAttempt === 0) {
                                    const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                                    return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
                                }
                                if (backwardCompatibleAttempt === 1) {
                                    let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                                    updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                                    return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
                                }

                                return {
                                    success: false,
                                    message: "Signature mismatch"
                                };
                            }

                            return {
                                success: true,
                                decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
                            };
                        }
                        exports.decode = decode;

                        return exports;
                    }
                    exports.init = init;

                    return exports;
                })());
                const decode = codec.init(cryptoEngine).decode;

                /**
                 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
                 *
                 * @param {{
                 *  staticryptEncryptedMsgUniqueVariableName: string,
                 *  isRememberEnabled: boolean,
                 *  rememberDurationInDays: number,
                 *  staticryptSaltUniqueVariableName: string,
                 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
                 *
                 * @param {{
                 *  rememberExpirationKey: string,
                 *  rememberPassphraseKey: string,
                 *  replaceHtmlCallback: function,
                 *  clearLocalStorageCallback: function,
                 * }} templateConfig - object of data that can be configured by a custom password_template.
                 */
                function init(staticryptConfig, templateConfig) {
                    const exports = {};

                    /**
                     * Decrypt our encrypted page, replace the whole HTML.
                     *
                     * @param {string} hashedPassword
                     * @returns {Promise<boolean>}
                     */
                    async function decryptAndReplaceHtml(hashedPassword) {
                        const {
                            staticryptEncryptedMsgUniqueVariableName,
                            staticryptSaltUniqueVariableName
                        } = staticryptConfig;
                        const {
                            replaceHtmlCallback
                        } = templateConfig;

                        const result = await decode(
                            staticryptEncryptedMsgUniqueVariableName,
                            hashedPassword,
                            staticryptSaltUniqueVariableName
                        );
                        if (!result.success) {
                            return false;
                        }
                        const plainHTML = result.decoded;

                        // if the user configured a callback call it, otherwise just replace the whole HTML
                        if (typeof replaceHtmlCallback === "function") {
                            replaceHtmlCallback(plainHTML);
                        } else {
                            document.write(plainHTML);
                            document.close();
                        }

                        return true;
                    }

                    /**
                     * Attempt to decrypt the page and replace the whole HTML.
                     *
                     * @param {string} password
                     * @param {boolean} isRememberChecked
                     *
                     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
                     *   expose more information in the future we can do it without breaking the password_template
                     */
                    async function handleDecryptionOfPage(password, isRememberChecked) {
                        const {
                            staticryptSaltUniqueVariableName
                        } = staticryptConfig;

                        // decrypt and replace the whole page
                        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
                        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
                    }
                    exports.handleDecryptionOfPage = handleDecryptionOfPage;

                    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
                        const {
                            isRememberEnabled,
                            rememberDurationInDays
                        } = staticryptConfig;
                        const {
                            rememberExpirationKey,
                            rememberPassphraseKey
                        } = templateConfig;

                        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

                        if (!isDecryptionSuccessful) {
                            return {
                                isSuccessful: false,
                                hashedPassword,
                            };
                        }

                        // remember the hashedPassword and set its expiration if necessary
                        if (isRememberEnabled && isRememberChecked) {
                            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

                            // set the expiration if the duration isn't 0 (meaning no expiration)
                            if (rememberDurationInDays > 0) {
                                window.localStorage.setItem(
                                    rememberExpirationKey,
                                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                                );
                            }
                        }

                        return {
                            isSuccessful: true,
                            hashedPassword,
                        };
                    }
                    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

                    /**
                     * Clear localstorage from staticrypt related values
                     */
                    function clearLocalStorage() {
                        const {
                            clearLocalStorageCallback,
                            rememberExpirationKey,
                            rememberPassphraseKey
                        } = templateConfig;

                        if (typeof clearLocalStorageCallback === "function") {
                            clearLocalStorageCallback();
                        } else {
                            localStorage.removeItem(rememberPassphraseKey);
                            localStorage.removeItem(rememberExpirationKey);
                        }
                    }

                    async function handleDecryptOnLoad() {
                        let isSuccessful = await decryptOnLoadFromUrl();

                        if (!isSuccessful) {
                            isSuccessful = await decryptOnLoadFromRememberMe();
                        }

                        return {
                            isSuccessful
                        };
                    }
                    exports.handleDecryptOnLoad = handleDecryptOnLoad;

                    /**
                     * Clear storage if we are logging out
                     *
                     * @returns {boolean} - whether we logged out
                     */
                    function logoutIfNeeded() {
                        const logoutKey = "staticrypt_logout";

                        // handle logout through query param
                        const queryParams = new URLSearchParams(window.location.search);
                        if (queryParams.has(logoutKey)) {
                            clearLocalStorage();
                            return true;
                        }

                        // handle logout through URL fragment
                        const hash = window.location.hash.substring(1);
                        if (hash.includes(logoutKey)) {
                            clearLocalStorage();
                            return true;
                        }

                        return false;
                    }

                    /**
                     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
                     * try to do it if needed.
                     *
                     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
                     */
                    async function decryptOnLoadFromRememberMe() {
                        const {
                            rememberDurationInDays
                        } = staticryptConfig;
                        const {
                            rememberExpirationKey,
                            rememberPassphraseKey
                        } = templateConfig;

                        // if we are login out, terminate
                        if (logoutIfNeeded()) {
                            return false;
                        }

                        // if there is expiration configured, check if we're not beyond the expiration
                        if (rememberDurationInDays && rememberDurationInDays > 0) {
                            const expiration = localStorage.getItem(rememberExpirationKey),
                                isExpired = expiration && new Date().getTime() > parseInt(expiration);

                            if (isExpired) {
                                clearLocalStorage();
                                return false;
                            }
                        }

                        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

                        if (hashedPassword) {
                            // try to decrypt
                            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

                            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
                            // the user fill the password form again
                            if (!isDecryptionSuccessful) {
                                clearLocalStorage();
                                return false;
                            }

                            return true;
                        }

                        return false;
                    }

                    async function decryptOnLoadFromUrl() {
                        const passwordKey = "staticrypt_pwd";
                        const rememberMeKey = "remember_me";

                        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
                        // since it sends the hashed password to the server which isn't needed)
                        const queryParams = new URLSearchParams(window.location.search);
                        const hashedPasswordQuery = queryParams.get(passwordKey);
                        const rememberMeQuery = queryParams.get(rememberMeKey);

                        const urlFragment = window.location.hash.substring(1);
                        // get the password from the url fragment
                        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
                        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
                        const rememberMeFragment = urlFragment.includes(rememberMeKey);

                        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
                        const rememberMe = rememberMeFragment || rememberMeQuery;

                        if (hashedPassword) {
                            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
                        }

                        return false;
                    }

                    return exports;
                }
                exports.init = init;

                return exports;
            })());;
        const templateError = "Oops! It seems you’ve entered an incorrect password. Please try again.",
            templateToggleAltShow = "template_toggle_show",
            templateToggleAltHide = "template_toggle_hide",
            isRememberEnabled = false,
            staticryptConfig = {
                "staticryptEncryptedMsgUniqueVariableName": "6e22d77badf73a36808d3d2b0699513cffcfd12adc3b4a204d079c83f4f6c5a5ea1a16da805eb8563f8cf5be01eff1e63c081c7caa3049a3a3043a78ac499cb832f8d0f01ff5fcbf7bb7c4cc7b5c9a2783177ff27148163a150bc67c5ce11843dde0476704cd33a5162b153439f697fa709134deb242ae689bed9190398dc1de625563a632cda4393299b458a72ba5cb38499ead3afbdee36a80830cc66cb7f6a7ba4a181c4cdd195adbf1b03a70209f52a259d76e614960625516b9ec194bdc1b9c6aaf350f645622274df942ac5fec6b73a17a07fffd2d54ef302556221ef67644539085cdf01d59465b0331403fa8ded5bced56e651845ce210fa9ede57dbf64425496fa59ed5a63ecd3703ed7ec2b3077ab7c5a01576fba785e4b8d61a249b9a6074e15b0bcc89650fba299b617d90485a6e8ab5783ab16effb3dc07a62ff3f1027a551a75eca3f2a1f3c5407628b666e4f9e09e03d58deedf6fff0e31b5720e182eb355f710177848524ae444998cce1480623bc3d439f41c93c1d4078ffde783075712fc0149323c25cbdd4c9b12824f5c6fb049b2d1ecd729af3da65ef3d9106bccf20d6e91c3cc97e5a9c3c4ea185b71b7ed5941368544986b38f0a9eb95c86de0f6d94300e99d460a16ccd9fa39fd71c776dd7b0182e3bd0d11d691b6f06976cfab57483cddc38b52fb72ea94bbcc361300a92a37f06f2433fb93df200a88608736bcd720a1275078a093f0dbb562a7fec2b8110f0af600fc54a4b41cf3b6902b8bbb9db87c1078bc89cf4a8da8c9ae82cb531a6407541c4219fbdb75ea4151e18c9cf9ed5a2cb0dd80782a2eb8d6fec9b25ca8d0ec8c562e2ec03922bfe67b10a16eb502539ae2f71bbc5115caeae54211b6ef53ac94e815d60c861deb3cd260981df509b7c9275ab5facd709995fbeb8b6bc31504509e1f7ae599dd15dc5fba64bf3c7664dbec514991a28d20bfe546dd08a1ff6896971117135c186bdb8d79b4a743eb790bb2c88a5929e1d7a684f0eaead524d973df50ec39d23ab74f5f151b52bfe2b414414e711dd525406aab6b1c7e12a56a2b6690e86064d399deb23cd5ad0fea3ee332eea9f3892e5de005defa7cb05a05bdfa8e5054b30275a157fad43e780d94b43bb2f4044ff062c4b7dd137461217edbea4fcc71a8f797bef36e43623a67e82edab425d7e5fcb134b61d30e09774e03e2ebe55ed5b13089477c50276b233841c22e5f2175a9aa238524fb5584878c97152ebc70684731d22caf8537ec9515cb8caff1c5b0617be8c39829754b89875b811a7c26fea23431a3d9e17352c47547a38915a6d82464266ae4fe85e4b31cd11a7fbda841118628e4aa6f0a19726d72fedfb95dec8cf19c5da01d0587838f59b7ef7e31d9acd00ae5c320c0a724eda8fde3a25a9b4e8f6a7d5cb70402eca387f1525870d3ffc9378a4a8786d27d52cde601e12895bcaed330cecf543ef05cd5166363b6aaf7bf2af86cc80d37e037f7f4df73a0dfa53f64bc86d5c2d3f477f2564cd25a7ee06efb9df5330ef69de576fc60248dcea22cbcd42083f3e91229b8157c5ea90c12be632d1bc623a3af7af2a9979d09cb77c8a38ba8de2d4dd696328f0785e5b40107d37598f9300ca01b2511eed9d2104ce55fe788f16890c785c4b1703fc7acbf5bdfa3d305d15545318cba99f5b0a7a96178a989125e058e4f99de6791cb97e82c44761939ee04d70e0e5c001a9032c4fcdd3208c9a29bc2e3477a7f14627cee204cd32fbffa83a1f5b2ddb8b327fa525c52ff3f6c86e03f984e13c95560f0aabcdfde0076c293764d7316bf37872f68e4ecbaaf2e88b9884d7480c4cac03b58ced8a19ee87442982fab02d395152ad5d7116d8bfaaaf0b25f368099f5e8d08535b32ad7d52978cd937010e0576be88ee51da6513963e9006839edf4705ff1dc9704ec1de6a61aaff0be276a0bb98e5255b671747e298b33eab3974c4f06a23f573b038fcd8b116a9413eda7d3667f1863d6ac7471ad2b9fac2f4956f97f40840ccef3d4a68025b1423a0d8e0a007d6bbf12dff3d3c7e11590b08f0b21bf4eee6be0d67277c2720080d470330d1f24f5f37ab347e00e6d87fa1866dbdc10439723c673af6c01267ac2e95e753384dbfa6003c70d43d6578743d694b58bf38b63791af2ba0df972f599e4d83aa8c0db656e8172ae1b04d04772243b25eba58654ad752f0196be6ab6a006f1be81b11cb634e336ed0c870bb53e8ac005686e4d2473ccc8be18157483418a52005e7ea4983a6f09b99282448c83457ce5f6621faa029bb1c739129ccd96c8e06c0a85220a56607815248037bbfc40f7ca223fa178380d39f44419cb93534059eca846b1b025b93e60a4be9ad80d3d91d4e0ec1eca29f5b85c3a00b00c8f20de3c6cea79b860ccb9b1f6b4b3b2e8aa2a6106c4a416e569fc845603f68ccbe77e23bfc3ad386bad004323e503977c9ad0c0b9382cbdc5c3d7d5a8dd99b17d52aee32487280b40d007360bc819588dbdb804f36fadc74b565701ed77c986df24e5d99102591420c1cf7bdf6b397ef823fa76ab87c97003d0d842ff97bdc394ae9cfe8ed5a92427e1f7455b1637d27f3a281536637400bcc527c69c28acf24bf81c0715c8e234f11b713b3aba6f34ff9f1a8082e18da51be6b5de6583af6f52e95a4289e6bdf180f5dca78fb10790daa2bf089fd6e542bf3ea4a36e7e23fba605b57f233fb3e12979ce431e64295ab868025837b29125cd594d9bb49c4de7570c5d41f794ea20eab658f5d6c9bb552c43c5a552d34b6bb24dd24e0294654f98e1ee4251169b29c268b23a6dcf39c789080683f4557895b35f3592c207310d80d8404ea8b51e3ed7270313906892697a4acf6b9358906173f522dcfcc7f99dde14922a2ca2935f160b88a9288e0dcdac6b339cfe5d47c74c7a999525575b5af310fbd8559fd6b914e3dd26e755e10a5cfa5e7aea4718b27eb80ae6d4805904267182e2314078b9513cdfcd79e12ef71460d29a054be2aa2bf54d75ed546853665728971712f62d737b8d865c8404f8ff72f7c350bed94eae7802624ac60fb0f057dfe4521177605faf7f3a92942e2db5ae0f3b61078244b6ca72b7c656762e139153ac0fbb6e62c5332f2cfba828b92b375de46e2db0d612eaab5664420018da7382ea7ff80ab732645ddc35119cf3eb09e0b0a8e117fb806960af0d2d1e89c67c84e5ec05a4734ef25f608004cbf0b33acfdfca1794754053114e2a82e1d9e8d0311fe459557881eefe93cd55d1016d377eec502f319f4b5e04bdfa18b84776581ad265f867222e0694ae0293fbff5046260aba173d244fa336132ce8cb18e5418fe4d090396d9db20eacc4863be29911516f7f65cc0b0a02ee211da39f9b913c0d1ce1d86dec3b027f5ee250f5a4339dc4cecc302767a41424f7d226ae0aa8af42a8ac5b649842e86a6cb7f8e4fa5a3d9cb6de95dbb1fa5f2f709e83e8f14127fae889d75442cad3802bce1275b1058fffa06a5d844ee340c8241505a47f35b7876a20eac602243b0d1fa113082edf36bcc6a2eb0d7c675ceb47687d77e634bcc5f7deff4e716b8590cf8b8106651a7f666918cd74fcc19a67964ab8ba65346e92af48f09744e0c288b43d2013bd9fb044402e35019828da1325aac58c0bae905818a81093a45044b3f6e4ca390fd6f449465bcda200fe6dcd23fa509185c96fb773c486eda2a4e19c412da70542d6987ea37e035f1b45642e509ce89a81d02583235542ba15d79d9b479fac3f546794cc3446bbe49a43c2203aa63196c4343a71c25fc557c08e8d15e34d5b27bc0616b81f9388f87545d0925435e48c18786d5aae36e8ee7aacda9d3db4d3bda3e9264aa748cdc1129b5364a5bc8729d0d66593b860ef4579534b6b1fd6cceecc76453fd926af2d443b863f130c8fc862afb5d9aa40b8b3974b25541d02af0a3d0c314d10c372b82a31fe827b41f463a0b29d6bdad6ca9787dc1bf482f1bd643e51c31d5656f8d8cd065d3a88f2fcd0a0fe3dcd6aea34fab29c94fda5581caa97845e3da2ca8a8dfc8ce1802febb49eee1d3db015f55bd2302466080ffe4759f1e24fa4a7a93f8f9a94e6b4344a57707dad0ac1b029634ac13e7acae27491f4e3f57e50e59048d222d34580817a91a6cdbff9b2af771baaea7738ac6656238b45c3b8edc3e276d544590d18f5288bf100a36458389a436734ddfaffb658faf20408f706d9019895a729603411632f18b15854da14fdd9a49b089cd94c290bb2959cb6246fd16c45dd5368805753db5d2acaad492a15606a76b1d94630ae38adfde6694431beac1123c59e002da4ca95dc287f953caab96f84732817c37ff71a59f71c6ba8521809371d2cc7cefda0ce7b04800f2b2c9f54fe63e6513c0ac640457fb3fad854e636e2d09d63bb1f7973365a049ed52d9091ee5636cc16dc03ed9c7e566959480c2c829c4da5e7d8e45f047da0634cff179973991dafeb57b6313e0c869aecb152929c1cfd99942895321ae1e987973e14eb5adce658a31c1cd62d520181ccfaceb86bed9c62a2316a22e06cbe41eb8703d7e515f93163d81cb673a9f3f93bb2e35d686db36d0a05bc70171608a0e149bf437e0b7d282d96831e351da9c2942754b3ff80ca329c4942317e165ef2d30a5253f60a94a1d9868a35b75b584253b0edecb8cc892ab1492523513abf5581292eb23165c0a152673781ca4fc686edb6608c8c82f6a22c5d356f0891432d5438d6bc59d2d95918633392eb728e9c1f9dca3fa460d201ec266ca63b5cb428ed29a049c2bd2310b1b2327b3bd3f4b18604ae9084dcf41a58a534e22672a1d293568c795687995a6cd5184fbb94dd1238a3a6c5e20a10e417e3dd247bdd7a05c5b13e6583cf4f678604bff67c42bda034bd1c6c63e87920fe846844098981e5ffbe97b1cecda4b529730e4b44eda46acd878213f84ccd184f18938e47090fbe072120b3512f4d02b3b334aeea9b583745dd718c82fbedbfe708f413b0c5576a392258f1b3f014160205f1894c0e67032b5d5f3b74bbf4d4aab48ac0f1ebe3601573fb5927a2c0588a2b8195ca596d1c1c83a5592709d004682733973d0c669e8096f56e39dcc7e81e4db7df5379e7887baf78cf4e351575f2a90b22af90f818a09dba7860c5eee2aa6bce2732f2c1b23b8398e95a03505c4bb64b2c17a7c76c3df3ec3fbb0ba7cbdf6f36d7fef428557c27f89b6dc21a2f8ebc95c6e5fdd2164001011da9be6da980a8c28f165db9e4e623e51991c5d3efd94a80b4da3e55182f9ea5a163b434b05c893dcf73a7a3dc2797bbd38f718aea1c0efcfb15e1c3965062691aac640ec3a23c6eef921dcb55c4345229bb7507ea0673dbc81eb4a049787bb837338b0060b36b3097621398f5a1a52bb7b0e3b9f50c237498a1b883a6617be26f54105f24d6501171cad3e43d594d5e3d098454b898299bff641f5538ba001f4434e4c47bba44bf4ce7329cf6add7a874a514f81928c01bceabd80d372bff8efac896f7e5ffe64792e68aea9235c4efb185bb060b79c88b6a8171ba5f1c86d13fa641b0b84a21f96c5fcffa23cf5e67182f7f4e237589d3c633b81de4e08639b56c2d0507f1f45e87e57e602e165e76225",
                "isRememberEnabled": false,
                "rememberDurationInDays": "0",
                "staticryptSaltUniqueVariableName": "70513af6d0e4c6e5167c5e6205e80ca0"
            };

        // you can edit these values to customize some of the behavior of StatiCrypt
        const templateConfig = {
            rememberExpirationKey: "staticrypt_expiration",
            rememberPassphraseKey: "staticrypt_passphrase",
            replaceHtmlCallback: null,
            clearLocalStorageCallback: null,
        };

        // init the staticrypt engine
        const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

        // try to automatically decrypt on load if there is a saved password
        window.onload = async function() {
            const {
                isSuccessful
            } = await staticrypt.handleDecryptOnLoad();

            // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
            // replaced, no need to do anything
            if (!isSuccessful) {
                // hide loading screen
                document.getElementById("staticrypt_loading").classList.add("hidden");
                document.getElementById("staticrypt_content").classList.remove("hidden");
                document.getElementById("staticrypt-password").focus();

                // show the remember me checkbox
                if (isRememberEnabled) {
                    document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                }
            }
        };

        // toggle password visibility
        const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
        // these two icons are coming from FontAwesome
        const imgSrcEyeClosed =
            "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
        const imgSrcEyeOpened =
            "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
        toggleIcon.addEventListener("click", function() {
            const passwordInput = document.getElementById("staticrypt-password");
            if (passwordInput.type === "password") {
                passwordInput.type = "text";
                toggleIcon.src = imgSrcEyeOpened;
                toggleIcon.alt = templateToggleAltHide;
                toggleIcon.title = templateToggleAltHide;
            } else {
                passwordInput.type = "password";
                toggleIcon.src = imgSrcEyeClosed;
                toggleIcon.alt = templateToggleAltShow;
                toggleIcon.title = templateToggleAltShow;
            }
        });

        // handle password form submission
        document.getElementById("staticrypt-form").addEventListener("submit", async function(e) {
            e.preventDefault();

            const password = document.getElementById("staticrypt-password").value,
                isRememberChecked = document.getElementById("staticrypt-remember").checked;

            const {
                isSuccessful
            } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

            if (!isSuccessful) {
                alert(templateError);
            }
        });
    </script>
</body>

</html>
